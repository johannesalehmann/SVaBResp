mdp

label "obj" = mg=1; //(mg>0) & (mg=2 | !someone_attacking | everyone_attacking); // (g1>0&g2>0&g3>0&master_general_done) & (sound_the_trumpet | !(g1=g2 & g2=g3)); //(g1=1&g2=2&g3=2)|(g1=2&g2=1&g3=2)|(g1=2&g2=2&g3=1)|(g1=1&g2=1&g3=2)|(g1=2&g2=1&g3=1)|(g1=1&g2=2&g3=1);

module Castle
    someone_attacking: bool init true;
    everyone_attacking: bool init false;
    attacks_evaluated: bool init false;

    [] (g1>0 & g2>0 & g3>0 & g4>0 & !attacks_evaluated) -> (attacks_evaluated '= true) & (someone_attacking '= g1=1|g2=1|g3=1|g4=1) & (everyone_attacking '= g1=1&g2=1&g3=1&g4=1) & (g1'=0) & (g2'=0) & (g3'=0) & (g4'=0);
endmodule

module MasterGeneral
    mg: [0..2] init 0;

    [] (mg=0 & attacks_evaluated) -> (mg'=1); // Do nothing
    [] (mg=0 & attacks_evaluated) -> (mg'=2); // Sound the trumpet: call off the attacks
    [] (mg>0) -> (mg'=mg);
endmodule

module General1
    g1: [0..2] init 0;
    [] (g1=0 & !attacks_evaluated) -> (g1'=1); // Attack!
    [] (g1=0 & !attacks_evaluated) -> (g1'=2); // Don't attack!
endmodule

module General2
    g2: [0..2] init 0;
    [] (g2=0 & !attacks_evaluated) -> (g2'=1); // Attack!
    [] (g2=0 & !attacks_evaluated) -> (g2'=2); // Don't attack!
endmodule

module General3
    g3: [0..2] init 0;
    [] (g3=0 & !attacks_evaluated) -> (g3'=1); // Attack!
    [] (g3=0 & !attacks_evaluated) -> (g3'=2); // Don't attack!
endmodule

// General 4 attacks after general 2 and 3 have decided whether to attack. This is to achieve a model size that is
// suitable for evaluation (3 generals are so small that results are very noisy and 4 unrestricted generals are so large
// and have so many responsible states that even refinement does not deliver results)

module General4
    g4: [0..2] init 0;
    [] (g4=0 & g3>0 & g2>0 & !attacks_evaluated) -> (g4'=1); // Attack!
    [] (g4=0 & g3>0 & g2>0 & !attacks_evaluated) -> (g4'=2); // Don't attack!
endmodule